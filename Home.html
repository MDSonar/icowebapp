<!DOCTYPE html>
<html>
<head>
    <title>FWXAPI</title>
    <style>
        body{font-family: Arial, Helvetica, sans-serif; padding: 20px;}
        .data-container{margin-top: 20px;background: #f4f4f4; padding: 15px;border-radius: 8px;box-shadow: 0 0 5px rgba(0,0,0,0.1);}
        h3 {color: #2c3e50;}
        table{width: 100%;text-align: left;background-color: #fff;}
        th{background-color: #3498db;}
        td,th{ padding: 8px;}
        button{background-color: #3498db;color: white;border: none;padding: 10px 20px;margin: 10px 10px 0 0;border-radius: 5px;cursor: pointer;font-size: 14px;transition: background-color 0.3s ease;}
        button:hover{background-color: #2980b9;}
        input[type="number"],select{padding: 10px;font-size: 14px;margin: 10px 10px 0 0;border: 1px solid #ccc;border-radius: 5px;outline:none;transition: border-color 0.3s ease, box-shadow 0.3s ease;width: 180px;}
        input[type="number"]:focus,select:focus{border-color: #3498db;box-shadow: 0 0 5px rgba(52, 152, 219,0.5);}
        input[type="text"],select{padding: 10px;font-size: 14px;margin: 10px 10px 0 0;border: 1px solid #ccc;border-radius: 5px;outline:none;transition: border-color 0.3s ease, box-shadow 0.3s ease;width: 180px;}
        input[type="text"]:focus,select:focus{border-color: #3498db;box-shadow: 0 0 5px rgba(52, 152, 219,0.5);}
        .collapsible{background-color: #3498db;color: white;cursor: pointer;padding: 12px;width: 100%;border: none;text-align: left;outline: none;font-size: 16px;border-radius: 5px;margin-top: 20px;transition: background-color 0.3s ease;}
        .collapsible:hover{background-color: #2980b9;}
        .content{padding: 10px 15px;display: none;overflow: hidden;background-color: #f9f9f9;border: 1px solid #ddd;border-top: none;border-radius: 0 0 5px 5px; margin-bottom: 10px;}
        #tokenTimer{display: inline-block;background-color: #ecf0f1;color: #2980b9;padding: 10px 15px; margin-left: 15px;border-radius: 5px;font-size: 14px;box-shadow: 0 0 4px rgba(0,0,0,0.1);vertical-align: middle;}
        .date-picker-container { display: flex; flex-direction: column;align-items: flex-start; gap: 10px; max-width: 400px; margin: 20px 0; font-family: 'Segoe UI', sans-serif; font-size: 14px; color: #333;}
        .date-picker-container label{ font-weight: 600;}
        .date-picker {padding: 10px; border: 1px solid #ccc; border-radius: 14px; font-size: 14px; background-color: #f9f9f9; transition: all 0.3s ease;}
        .date-picker:focus { outline: none; border-color: #0078d7; background-color: #fff; box-shadow: 0 0 5px rgba(0,120,215,0.3);}
    </style>
</head>
<body>

<button class="collapsible">Authorization</button>
<div class="content">
    <button onclick="logout()">Get New access token</button>
    <button onclick="checkAuth()">Check Authentication</button>
    <span id="tokenTimer" >Checking token...</span>
    <pre id="loginStatus" class="data-container">Authenticating...</pre>
    <label><input type="radio" name="authType" value="secret" onclick="saveAuthType()"> Secret-based</label>
    <label><input type="radio" name="authType" value="pkce" onclick="saveAuthType()" checked> PKCE</label>    
</div>

<button class="collapsible">Manual Request GET POST</button>   
<div class="content">
    <button onclick="getData()">Fetch via GET</button>
    <button onclick="postData()">Fetch via POST</button>
    <pre id="getPostOut" class="data-container">Press any button for data</pre>
</div>

<button class="collapsible">Live Data</button>
<div class="content">
    <label for="refreshRate">Refresh</label>
    <select id="refreshRate">
        <option value="200">200 ms</option>
        <option value="1000">1 s</option>
        <option value="5000" selected>5 s</option>
        <option value="10000">10 s</option>
    </select>
        <pre id="liveDataOut" class="data-container">Waiting for data...</pre>
</div>

<button class="collapsible">Write POST </button>
<div class="content">
    <input type="number" id="writeValue" placeholder="Enter Value">
    <button onclick="writeData()">Write</button>
    <pre id="writeOutput" class="data-container"></pre>
</div>

<button class="collapsible">Read DataSets</button>
<div class="content">    
    <button onclick="readDb()">Refresh</button>
    <pre id="readDataSet" class="data-container">Waiting for data...</pre>
</div>

<button class="collapsible">Read Historical Data</button>
<div class="content">
    <div class ="date-picker-container">
        <label for="startDateInput">Start Date & Time:</label>
        <input type="datetime-local" id="startDateInput" class="date-picker">
        
        <label for="endDateInput">End Date & Time:</label>
        <input type="datetime-local" id="endDateInput" class="date-picker">
    </div>
    <button onclick="fetchHHData()">Refresh</button>
    <pre id="getHHData" class="data-container">Waiting for data...</pre>
</div>

<button class="collapsible">Format</button>
<div class="content">
    <label><input type="radio" name="formatType" value="table" onclick="saveForamtType()"> Tabular</label>
    <label><input type="radio" name="formatType" value="json" onclick="saveForamtType()" checked> JSON</label>    
</div>

<!--Config-->
<script>

    const CLIENT_ID = 'TestRESTApi';
    const CLIENT_SECRET = '123456789'; //AuthorizationCode flow: client secret 
    const REDIRECT_URI = 'https://coe-win11-1/AnyGlass/Home.html';
    const AUTH_URL = 'https://coe-win11-1/fwxserverweb/security/connect/authorize';
    const TOKEN_URL = 'https://coe-win11-1/fwxserverweb/security/connect/token';
    const SCOPE = 'fwxserver offline_access';
    const API_URL = 'https://coe-win11-1/fwxapi/rest';

    let accessToken = localStorage.getItem("accessToken") || "";

    const getPostOut = document.getElementById('getPostOut');
    const liveDataOut = document.getElementById('liveDataOut');
    const loginStatus = document.getElementById('loginStatus');
    const formatType = localStorage.getItem('formatType');
    const writeOutput = document.getElementById('writeOutput');
    const readDataSet = document.getElementById('readDataSet');
    const getHHData = document.getElementById('getHHData');

    function logout(){
        localStorage.removeItem("accessToken");
        localStorage.removeItem("tokenExpiry");
        window.location.href = REDIRECT_URI;
    }

    //save authenticatoin type
    function saveAuthType(){
        const selected = document.querySelector('input[name="authType"]:checked').value;
        localStorage.setItem('authType', selected);
    }
    //save format type
    function saveForamtType(){
        const selected = document.querySelector('input[name="formatType"]:checked').value;
        localStorage.setItem('formatType',selected);
    }
   
    //Token time function
    function updateTokenTimer(){
        const expiry = parseInt(localStorage.getItem("tokenExpiry"),10);
        const now = Date.now();
        if(!expiry || expiry < now){
            document.getElementById("tokenTimer").textContent = "Token expired.";
            return;
        }
        const remaining = Math.floor((expiry-now)/1000);
        const min = Math.floor(remaining/60);
        const sec = remaining % 60;
        document.getElementById("tokenTimer").textContent = `Token valid for: ${min}m ${sec}s`;
    }

    //PKCE Code flow 
    function base64urlencode(str) {
        return btoa(String.fromCharCode.apply(null, new Uint8Array(str)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function sha256(plain){
        const encoder = new TextEncoder();
        const data = encoder.encode(plain);
        return await crypto.subtle.digest('SHA-256', data);
    }

    function generateCodeVerifier(){
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return Array.from(array, dec => ('0' + dec.toString(16)).slice(-2)).join('');
    }

    async function loginWithPKCE() {
        const codeVerifier = generateCodeVerifier();
        const codeChallenge = base64urlencode(await sha256(codeVerifier));
        sessionStorage.setItem('verifier',codeVerifier);
        
        const authURL = `${AUTH_URL}?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(SCOPE)}&code_challenge=${codeChallenge}&code_challenge_method=S256`;
        window.location.href = authURL;
    }


    //Authentication
    function checkAuth(){
        //const authType = document.querySelector('input[name="authType"]:checked')?.value || 'pkce';
        const authType = localStorage.getItem('authType') || 'pkce';
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        const error = urlParams.get('error');

        if(accessToken){//if already have accesstoken
            loginStatus.textContent = "Logged in with valid token.";
            updateTokenTimer();
            return;
        }
        if(error){
            loginStatus.textContent = "Auth Error :"+ error;
            return; 
        }

        if(authType === 'secret'){
            if(code){
                loginStatus.textContent = "Exchaning code for token...";
                fetch(TOKEN_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `grant_type=authorization_code&code=${code}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}`
                })
                .then(res => res.json())
                .then(data => {
                    if(data.access_token){
                        localStorage.setItem("accessToken",data.access_token);
                        loginStatus.textContent = "Token received!";
                        const expiresIn = data.expires_in;
                        const expirationTime = Date.now() + expiresIn * 1000;

                        localStorage.setItem("tokenExpiry",expirationTime);
                        window.history.replaceState({},document.title,REDIRECT_URI);
                        updateTokenTimer();
                        accessToken = data.access_token;
                    }else{
                        loginStatus.textContent = "Token exchage failed:\n"+JSON.stringify(data,null,2);
                    }
                })
                .catch(err => loginStatus.textContent = "Token Error: "+ err);
            }else{
                const state = 'xyz' + Date.now();
                const url = `${AUTH_URL}?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(SCOPE)}&state=${state}`;
                window.location.href = url;
            }
        }
        
        if(authType === 'pkce'){
            if(code){
                const codeVerifier = sessionStorage.getItem("verifier");
                fetch(TOKEN_URL, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: `grant_type=authorization_code&client_id=${CLIENT_ID}&code=${code}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&code_verifier=${codeVerifier}`
                })
                .then(res => res.json())
                .then(data =>{
                    if(data.access_token){
                        accessToken = data.access_token;
                        localStorage.setItem("accessToken",accessToken);
                        localStorage.setItem("tokenExpiry",Date.now() + (data.expires_in*1000));
                        loginStatus.textContent = "Token acquired successfully";
                        window.history.replaceState({},document.title,REDIRECT_URI);
                        updateTokenTimer();
                    }else{
                        loginStatus.textContent = "Token exchange failed: " + JSON.stringify(data);
                    }
                })
                .catch(err => loginStatus.textContent = "Token Error: "+ err);
            }else{
                loginWithPKCE();
            }
        }
    }

    //API Interaction 
    async function getData(){
    try{
        const response = await fetch('https://coe-win11-1/fwxapi/rest/data/?pointName=@sim64:Float.Random(1,-50.0,50.0,0).Value',{
            headers:{'Authorization':'Bearer ' + accessToken}
        });
        const data = await response.json();
        getPostOut.textContent = 'Reading real-time values (HTTP GET):\n'+JSON.stringify(data,null,2);
    }catch(err){
        getPostOut.textContent = 'GET Error:\n'+err;
    }
    }

    async function postData(){
    try{
        const response = await fetch('https://coe-win11-1/fwxapi/rest/data',{
            method: 'POST',
            headers:{
            'Content-Type':'application/json',
            'Authorization':'Bearer ' + accessToken
            },
            body: JSON.stringify({
            "PointName": ["ac:TestAPI/SimFloatStep","ac:TestAPI/SimLongRamp","ac:TestAPI/SimLongRandom"]
            })
        });
        const data = await response.json();
        getPostOut.textContent = 'Reading real-time values (HTTP POST):\n' + JSON.stringify(data,null,2);
    }catch(err){
        getPostOut.textContent = 'POST Error:\n'+err;
    }
    }

    async function writeData(){
        const value = document.getElementById('writeValue').value;
        if(value === ''){
            writeOutput.textContent = 'Entre value...';
            return;
        }
        try{
            const response = await fetch('https://coe-win11-1/fwxapi/rest/data/write',{
                method: 'POST',
                headers:{
                    'Content-Type':'application/json',
                    'Authorization':'Bearer ' + accessToken
                },
                body: JSON.stringify([{
                    "PointName": "ac:TestAPI/SimStaticLong",
                    "Value": parseFloat(value)
                }])
            });
            const result = await response.json();
            writeOutput.textContent = "Writing Real-Time Value HTTP POST:\n"+JSON.stringify(result,null,2);
        }catch(err){
            writeOutput.textContent = "Write Error: " + err;
        }
    }

    async function readDb(){
        try{
            const response = await fetch('https://coe-win11-1/fwxapi/rest/dataset?PointName=db:Northwind.Orders',{
                headers:{'Authorization':'Bearer ' + accessToken}
            });
            const result = await response.json();
            
            if(formatType === 'table'){
                //tabular 
                if(!Array.isArray(result) || result.length === 0){
                    readDataSet.innerHTML="<p>No Data returend </p>"
                    return;
                }
                //get att unique keys across the dataset 
                const allKeys = new Set();
                result.forEach(row => Object.keys(row).forEach(key => allKeys.add(key)));
                const headers = Array.from(allKeys);
                //Build HTML Table 
                let tableHtml = `<table border="1" cellspacing="0" cellpadding="5"><thead><tr>`;
                headers.forEach(header => {
                    tableHtml += `<th>${header}</th>`
                });
                tableHtml += `</tr></thead><tbody>`;

                result.forEach(row => {
                    tableHtml += `<tr>`;
                        headers.forEach(header => {
                            const cell = row[header] != null && row[header] !== undefined ? row[header] : '';
                            tableHtml += `<td>${cell}</td>`;
                        });
                        tableHtml += `</tr>`;
                });

                tableHtml += `</tbody></table>`;
                readDataSet.innerHTML = `<div>Reading DataSets HTTPS GET Dynamic Table: \n\n</div>${tableHtml}`;
            }else{ //JSON Format 
             readDataSet.textContent = "Reading DataSets HTTPS GET:\n"+ JSON.stringify(result,null,2);
            }
        }catch(err){
            readDataSet.textContent="ReadDB Error:" + err;
        }
    }

    async function fetchLiveData(){
    try{
        const response = await fetch('https://coe-win11-1/fwxapi/rest/data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json','Authorization':'Bearer ' + accessToken},
            body: JSON.stringify({
                "PointName": [
                    "ac:TestAPI/SimFloatStep",
                    "ac:TestAPI/SimLongRamp",
                    "ac:TestAPI/SimLongRandom",
                    "ac:TestAPI/SimStaticLong"
                ]
            })
        });
        const data = await response.json();
        if(formatType === 'table'){
            let html = "<table border='1' cellpadding='6' cellspacing='0' style='border-collapse:collapse;'>";
            html += "<tr><th>Point Name</th><th>Value</th><th>Timestamp</th><th>Quality</th></tr>";

            data.forEach(point => {
                const time = new Date(point.timestamp).toLocaleString(); // Fixed 'Data' typo and method name
                html += `<tr>
                            <td>${point.pointName}</td> 
                            <td>${point.value}</td>
                            <td>${time}</td>
                            <td>${point.quality}</td>
                        </tr>`;  // Closed tr properly
            });

            html += "</table>";
            liveDataOut.innerHTML = html;
         }else{
        //Direct Json 
         liveDataOut.textContent = "Reading Live Data HTTPS POST: \n" + JSON.stringify(data,null,2);
        }
    } catch (err) {
        liveDataOut.textContent = 'Live Fetch Error:\n' + err;
    }
    }

    async function fetchHHData(){
        try{
            const startRaw = document.getElementById("startDateInput").value;
            const endRaw = document.getElementById("endDateInput").value;
            const startDate = formatDateTimeLocal(startRaw);
            const endDate = formatDateTimeLocal(endRaw);

            if(!startDate || !endRaw){ 
                getHHData.textContent = "Enter both Start and End date.";
                return;
            }

            const pointName = "hh:\\Configuration\\TestAPI:HHACStatic";
            const point = encodeURIComponent("hh:\\Configuration\\TestAPI:HHACStatic");
            const response = await fetch(`https://coe-win11-1/fwxapi/rest/history?pointName=${point}&StartDate=${startDate}&EndDate=${endDate}`,{
                headers:{'Authorization':'Bearer ' + accessToken}
            });
            const data = await response.json();
            if(formatType === 'table'){
                if(!Array.isArray(data) || data.length === 0){
                    getHHData.textContent = "<p>No data returned</p>"
                    return;
                }
                const allKeys = new Set();
                data.forEach(row => Object.keys(row).forEach(key =>allKeys.add(key)));
                const headers = Array.from(allKeys);
                let tableHtml = `<table border="1" cellspacing="0" cellpadding="5"><thead><tr>`;
                headers.forEach(header => {
                    tableHtml += `<th>${header}</th>`
                });
                tableHtml += `</tr></thead><tbody>`;

                data.forEach(row => {
                    tableHtml += `<tr>`;
                        headers.forEach(header => {
                            const cell = row[header] != null && row[header] !== undefined ? row[header] : '';
                            tableHtml += `<td>${cell}</td>`; 
                        });
                        tableHtml += `</tr>`;
                });

                tableHtml += `</tbody></table>`;
                getHHData.innerHTML = `<div>Reading Raw Historical Data HTTPS GET: ${pointName} \n\n</div>${tableHtml}`;
            }else{
                getHHData.textContent = 'Reading Hyper Historical values (HTTPS GET):\n' + JSON.stringify(data,null,2);
            }
        }catch(err){
            getHHData.textContent = 'GET Error: \n'+err;
        }
    }

    //additional required functions 
    function formatDateTimeLocal (inputValue){
        if(!inputValue) return null;

        const date = new Date(inputValue);
        const offsetMinutes = date.getTimezoneOffset();
        const offsetSign = offsetMinutes > 0 ? "-" : "+";
        const pad = n => String(Math.abs(n)).padStart(2,'0');
        const offsetHours = pad(Math.floor(Math.abs(offsetMinutes)/60));
        const offsetMins = pad(Math.abs(offsetMinutes)%60);
        const offsetStr = `${offsetSign}${offsetHours}${offsetMins}`;

        return date.toISOString().slice(0,19) + offsetStr;
    }

    let refreshInterval = 5000;
    let intervalId = null;

    document.getElementById('refreshRate').addEventListener('change', function () {
        refreshInterval = parseInt(this.value);
        clearInterval(intervalId);
        intervalId = setInterval(fetchLiveData, refreshInterval);
    });
    fetchLiveData();

    checkAuth();

    //just 
    function setDefaultDate(){
        const now = new Date();
        const yesterday = new Date(now);
        yesterday.setDate(now.getDate()-1);
        const formatInput = d => d.toISOString().slice(0,16);
        document.getElementById('startDateInput').value = formatInput(yesterday);
        document.getElementById('endDateInput').value = formatInput(now);
    }

    window.onload = setDefaultDate;

    //Related to UI 
    document.querySelectorAll(".collapsible").forEach(btn =>{
        btn.addEventListener("click",function(){
            this.classList.toggle("active");
            let content = this.nextElementSibling;
            //content.style.display = content.style.display === "block" ? "none": "block";

            const wasHidden = content.style.display !== "block";
            content.style.display = wasHidden ? "block" : "none";
            
            //when the authorization section opens, update token timer
            if(this.textContent.includes("Authorization") && !wasHidden){
                updateTokenTimer();
            }
        });
    });

    //on page load read saved value and update UI
    window.addEventListener('DOMContentLoaded',()=>{
        // Handle saved authType
        const savedType = localStorage.getItem('authType') || 'pkce';
        document.querySelector(`input[name="authType"][value="${savedType}"]`).checked = true;
        //Handle saved format type 
        const savedFormatType = localStorage.getItem('formatType') || 'pkce';
        document.querySelector(`input[name="formatType"][value="${savedFormatType}"]`).checked = true;
    });


</script>
</body>
</html>
